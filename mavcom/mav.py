#!/usr/bin/env python

# Copyright 2012, Holger Steinhaus
# Released under the GNU GPL version 3 or later

# This program packetizes a binary MAVLink stream. The resulting packets are stored into a PCAP file, which is
# compatible to tools like Wireshark.

# The program tries to synchronize to the packet structure in a robust way, using the SOF magic, the potential
# packet length information and the next SOF magic. Additionally the CRC is verified.

# Hint: A MAVLink protocol dissector (parser) for Wireshark may be generated by mavgen.py.

# dependency: Python construct library (python-construct on Debian/Ubuntu), "easy_install construct" elsewhere
import io

from pymavlink import mavutil

from construct import ULInt16, Struct, Byte, Const
from construct.core import FieldError


MAVLINK_MAGIC = 0xfe
write_junk = True

# copied from ardupilotmega.h (git changeset 694536afb882068f50da1fc296944087aa207f9f, Dec 02 2012
MAVLINK_MESSAGE_CRCS  = (50, 124, 137, 0, 237, 217, 104, 119, 0, 0, 0, 89, 0, 0, 0, 0, 0, 0, 0, 0, 214, 159, 220, 168, 24, 23, 170, 144, 67, 115, 39, 246, 185, 104, 237, 244, 242, 212, 9, 254, 230, 28, 28, 132, 221, 232, 11, 153, 41, 39, 214, 223, 141, 33, 15, 3, 100, 24, 239, 238, 30, 240, 183, 130, 130, 0, 148, 21, 0, 243, 124, 0, 0, 0, 20, 0, 152, 143, 0, 0, 127, 106, 0, 0, 0, 0, 0, 0, 0, 231, 183, 63, 54, 0, 0, 0, 0, 0, 0, 0, 175, 102, 158, 208, 56, 93, 0, 0, 0, 0, 235, 93, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 42, 241, 15, 134, 219, 208, 188, 84, 22, 19, 21, 134, 0, 78, 68, 189, 127, 111, 21, 21, 144, 1, 234, 73, 181, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 204, 49, 170, 44, 83, 46, 0)

INVALID_CRC = 0x1

class Packet:
    __slots__ = ('seq', 'crc_flag', 'data')
    
    def __init__(self, seq: int, crc_flag, data: bytes):
        self.seq = seq
        self.crc_flag = crc_flag
        self.data = data


class Mavlink:
    _packet_start = b'\xfe'
    _header_struct = Struct('header',
        Const(Byte('magic'), MAVLINK_MAGIC),
        Byte('plength'),
        Byte('sequence'),
        Byte('sysid'),
        Byte('compid'),
        Byte('msgid'),
    )
    def __init__(self, stream: io.BinaryIO):  # , mode="r" currently only reading is available
        self.stream = io.BufferedReader(stream)
        self.packet_seq = 0

    def read_packet(self):
        header_bytes = self.stream.peek(6)
        header = Mavlink._header_struct.parse(header_bytes)
        return header, self.stream.read(6 + header['plength'] + 2)

    def find_next_frame(self) -> int:
        i = 0
        while True:
            i += 1
            b = self.stream.read(1)
            if b == Mavlink._packet_start:
                self.packet_seq += 1
                return i
            if b is None:
                return 0

    def read(self) -> Packet:
        shift = self.find_next_frame()
        if shift == 0:
            return None

        header, packet = self.read_packet()
        if len(packet) < (6 + header['plength'] + 2):
            return None

        try:
            pkt_crc = ULInt16('crc').parse(packet[-2:])
        except FieldError:
            return Packet(self.packet_seq, INVALID_CRC, None)

        cc = mavutil.x25crc(packet[:-2])
        cc.accumulate(chr(MAVLINK_MESSAGE_CRCS[header['msgid']]))
        x25_crc = cc.crc
        if x25_crc != pkt_crc:
            crc_flag = INVALID_CRC
        else:
            crc_flag = 0
        if chr(MAVLINK_MAGIC) != self.stream.peek(1):
            # packet has invalid length
            return Packet(self.packet_seq, INVALID_CRC, None)

        return Packet(self.packet_seq, crc_flag, packet)

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            p = self.read()
            if p is None:
                raise StopIteration()
            if p.crc_flag == INVALID_CRC:
                continue
            return p